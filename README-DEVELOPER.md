# BAZAAR - Документация для разработчиков

## Обзор проекта

BAZAAR - это онлайн-магазин по продаже цветочных букетов, разработанный с использованием современного стека технологий React. Проект реализует красивый и элегантный дизайн в стиле модного дома с золотыми акцентами и цветочными мотивами.

## Технологический стек

### Основные технологии
- **React 18** - библиотека для создания пользовательских интерфейсов
- **TypeScript** - типизированный JavaScript
- **React Router v6** - роутинг приложения
- **Redux Toolkit** - управление состоянием приложения
- **Webpack 5** - сборка проекта
- **OpenLayers** - карты для страницы контактов и доставки

### Инструменты разработки
- **ESLint** - статический анализ кода
- **Babel** - транспиляция кода
- **Webpack Dev Server** - локальный сервер разработки

## Структура проекта

```
bazaar-front/
├── dist/               # Собранный проект (создается при сборке)
├── node_modules/       # Зависимости проекта
├── public/             # Статические файлы
├── src/                # Исходный код
│   ├── components/     # React компоненты
│   │   ├── App.tsx     # Корневой компонент приложения
│   │   ├── common/     # Общие компоненты (кнопки, формы и т.д.)
│   │   ├── layout/     # Компоненты макета (шапка, подвал)
│   │   ├── pages/      # Компоненты страниц
│   │   ├── catalog/    # Компоненты каталога товаров
│   │   ├── cart/       # Компоненты корзины
│   │   ├── products/   # Компоненты товаров
│   │   ├── collections/# Компоненты для коллекций
│   │   ├── map/        # Компоненты для работы с картой
│   │   └── quiz/       # Компоненты для квиза выбора букета
│   ├── constants/      # Константы проекта
│   ├── fonts/          # Шрифты
│   ├── hooks/          # Пользовательские хуки
│   ├── images/         # Изображения
│   ├── mocks/          # Моковые данные для разработки
│   ├── store/          # Redux хранилище
│   │   ├── store.ts    # Конфигурация хранилища
│   │   └── cartSlice.ts# Срез для работы с корзиной
│   ├── styles/         # Стили CSS
│   ├── types/          # TypeScript типы
│   ├── index.css       # Базовые стили
│   └── index.tsx       # Точка входа приложения
├── .eslintrc.js        # Конфигурация ESLint
├── .gitignore          # Файлы, игнорируемые Git
├── package.json        # Зависимости и скрипты
├── package-lock.json   # Точные версии зависимостей
├── README.md           # Основная документация проекта
├── README-style-guide.md # Руководство по стилю
├── tsconfig.json       # Конфигурация TypeScript
└── webpack.config.js   # Конфигурация сборки
```

## Установка и запуск

### Требования
- Node.js >= 16.x
- npm >= 8.x

### Установка
```bash
# Клонирование репозитория
git clone <url-репозитория>
cd bazaar-front

# Установка зависимостей
npm install
```

### Запуск для разработки
```bash
npm start
```
Приложение будет доступно по адресу [http://localhost:3000](http://localhost:3000)

### Сборка для продакшена
```bash
npm run build
```
Собранное приложение будет находиться в директории `dist/`

### Анализ бандла
```bash
npm run analyze
```
Откроет интерактивный анализатор размера бандла

## Разработка

### Архитектура приложения

Проект построен по принципу компонентного подхода с использованием функциональных компонентов React. Для управления состоянием используется Redux Toolkit.

#### Маршрутизация

Маршрутизация реализована с помощью React Router v6. Основные маршруты определены в компоненте `App.tsx`. Для оптимизации используется ленивая загрузка страниц с помощью `React.lazy()`.

#### Состояние приложения

Глобальное состояние хранится в Redux хранилище. Для каждого логического раздела создаются отдельные срезы (slices).

Пример структуры хранилища:
- `cart` - состояние корзины (товары, общая сумма)

#### Стилизация

Для стилизации используется CSS с методологией БЭМ. Цветовая схема и типографика определены в руководстве по стилю (`README-style-guide.md`).

#### Требования к верстке и стилям

1. **Логические свойства CSS**
   - Использовать логические свойства вместо физических (direction-based) свойств:
     ```css
     /* Вместо этого */
     .element {
       margin-left: 1rem;
       padding-right: 2rem;
     }
     
     /* Использовать это */
     .element {
       margin-inline-start: 1rem;
       padding-inline-end: 2rem;
     }
     ```
   - Это обеспечивает лучшую поддержку интернационализации и разных направлений текста (RTL/LTR)

2. **Доступность (Web Accessibility)**
   - Соблюдать стандарты WCAG 2.1 (уровень AA)
   - Использовать атрибуты ARIA при необходимости (`aria-label`, `aria-expanded` и т.д.)
   - Обеспечивать достаточный контраст текста (минимум 4.5:1)
   - Поддерживать навигацию с клавиатуры (фокус, tabindex)
   - Добавлять метки к полям форм (связывать label с input)
   - Оптимизировать для скринридеров (правильная структура заголовков, альтернативный текст)
   - Тестировать с помощью инструментов аудита доступности (Lighthouse, axe)

3. **Семантическая верстка**
   - Использовать максимально семантические HTML-элементы:
     - `<header>`, `<footer>`, `<main>` для структуры страницы
     - `<article>`, `<section>`, `<nav>` для содержимого
     - `<button>` для кнопок (а не `<div>` с обработчиком)
     - `<ul>`, `<ol>` для списков
   - Избегать лишних оберток и вложенных `<div>`
   - В идеале стремиться к минимальному использованию `<div>`, заменяя их на семантические элементы
   - Использовать элементы по их предназначению (например, не использовать `<h1>` просто для стилизации)
   - Правильно применять заголовки (`<h1>` - `<h6>`) для создания иерархии документа

```css
/* Пример правильного использования семантической верстки */
<article class="product-card">
  <header class="product-card__header">
    <h3 class="product-card__title">Букет "Весенний"</h3>
  </header>
  <figure class="product-card__image-container">
    <img class="product-card__image" src="..." alt="Букет Весенний из тюльпанов и роз" />
  </figure>
  <footer class="product-card__footer">
    <p class="product-card__price">2 500 ₽</p>
    <button class="button product-card__button" type="button">В корзину</button>
  </footer>
</article>
```

### Руководство по стилю кода

#### Общие принципы
- Использовать функциональные компоненты
- TypeScript для всего кода
- Правила ESLint для обеспечения качества кода

#### Комментирование кода
- Добавлять JSDoc-комментарии к функциям, компонентам и их пропсам:
  ```tsx
  /**
   * Компонент для отображения карточки товара
   * @param {Product} product - Данные о товаре
   * @param {boolean} isFavorite - Флаг, указывающий на то, добавлен ли товар в избранное
   * @param {Function} onAddToCart - Функция-обработчик добавления товара в корзину
   * @returns {ReactElement} Карточка товара
   */
  const ProductCard = ({ product, isFavorite, onAddToCart }: ProductCardProps) => {
    // реализация
  };
  ```
- Комментировать сложные участки бизнес-логики, объясняя причины принятых решений
- Использовать говорящие имена переменных, функций и компонентов, уменьшая необходимость в комментариях
- Для временного кода использовать комментарии с пометками TODO, FIXME с указанием автора:
  ```tsx
  // TODO(username): Заменить хардкоданные значения на данные из API
  ```
- При изменении существующего кода, оставлять комментарии о причинах изменений
- Не использовать закомментированный код - для отслеживания изменений используйте систему контроля версий

#### Именование
- Компоненты: PascalCase (например, `ProductCard.tsx`)
- Хуки: camelCase с префиксом `use` (например, `useCart.ts`)
- Стили: kebab-case (например, `product-card.css`)

#### Импорты
- Использовать алиасы для импортов (`@components`, `@store`, и т.д.)
- Порядок импортов:
  1. Внешние библиотеки
  2. Типы, интерфейсы, утилиты
  3. Компоненты
  4. Стили

#### Типизация
- Использовать интерфейсы для пропсов компонентов
- Избегать `any`
- Использовать точечные импорты типов

### Централизованное хранилище типов

В проекте используется централизованный подход к управлению типами TypeScript. Все типы и интерфейсы хранятся в директории `src/types/` и логически группируются по файлам.

#### Организация типов

1. **Структура директории типов**:
   ```
   src/types/
   ├── README.md           # Документация по типам
   ├── catalog.ts          # Типы для каталога товаров
   ├── collection.ts       # Типы для коллекций
   ├── common.ts           # Общие типы
   ├── icon.ts             # Типы для иконок
   ├── index.ts            # Реэкспорт всех типов
   ├── layout.ts           # Типы для макета
   ├── lazyImage.ts        # Типы для ленивой загрузки изображений
   ├── map.ts              # Типы для карты магазинов
   ├── modal.ts            # Типы для модальных окон
   ├── product.ts          # Типы для продуктов
   ├── quiz.ts             # Типы для квиза
   ├── skeleton.ts         # Типы для скелетонов
   └── svg.d.ts            # Декларации для SVG
   ```

2. **Категоризация типов**:
   - **Типы сущностей**: Описывают бизнес-объекты (`Product`, `Store`, `Collection`)
   - **Типы свойств компонентов**: Определяют входные параметры компонентов (`ButtonProps`, `ProductCardProps`)
   - **Служебные типы**: Вспомогательные типы и утилиты (`Coordinates`, `SocialNetworkType`)

#### Использование централизованного хранилища типов

1. **Импорт типов**:
   ```typescript
   // Предпочтительно: Импорт через индексный файл
   import { Product, ProductCardProps } from '../../types';
   
   // Допустимо: Точечный импорт
   import { Store } from '../../types/map';
   ```

2. **Запрет локальных определений**:
   - Все типы должны быть определены в директории `types`
   - Запрещено дублировать определения типов в компонентах

   ```typescript
   // ❌ Неправильно: Локальное определение интерфейса
   interface Store {
     id: string;
     name: string;
     // ...
   }
   
   // ✅ Правильно: Импорт из централизованного хранилища
   import { Store } from '../../types/map';
   ```

3. **Избегайте циклических зависимостей**:
   - Внимательно проектируйте связи между типами
   - Если возникает циклическая зависимость, рассмотрите возможность реорганизации типов

#### Лучшие практики типизации

1. **Документирование типов**:
   - Добавляйте JSDoc-комментарии к каждому интерфейсу и типу:
   ```typescript
   /**
    * Информация о магазине
    */
   export interface Store {
     /** Идентификатор магазина */
     id: string;
     /** Название магазина */
     name: string;
     // ...
   }
   ```

2. **Связь между компонентами и типами**:
   - Связывайте пропсы компонентов с соответствующими типами данных:
   ```typescript
   // В файле types/product.ts
   export interface ProductCardProps {
     product: Product;
     // ...
   }
   
   // В компоненте
   import { ProductCardProps } from '../../types';
   
   const ProductCard = ({ product, ... }: ProductCardProps) => {
     // ...
   }
   ```

3. **Использование опциональных свойств**:
   - Явно указывайте, какие свойства опциональны:
   ```typescript
   export interface NavigationProps {
     /** Пункты навигации (опционально) */
     items?: NavItem[];
     /** Дополнительные классы */
     className?: string;
     // ...
   }
   ```

4. **Унификация возвращаемых типов**:
   - Стандартизируйте возвращаемые типы функций и хуков:
   ```typescript
   // Для хуков
   function useCart(): CartHookResult {
     // ...
   }
   
   // Для компонентов
   const Component = (): JSX.Element => {
     // ...
   }
   ```

#### Добавление новых типов

1. **Выбор подходящего файла**:
   - Проанализируйте существующие файлы с типами
   - Выберите наиболее подходящий файл для нового типа или создайте новый

2. **Определение интерфейса**:
   ```typescript
   // src/types/feature.ts
   
   /**
    * Новая сущность для функциональности X
    */
   export interface NewFeature {
     /** Уникальный идентификатор */
     id: string;
     /** Название */
     name: string;
     // Остальные свойства
   }
   
   /**
    * Свойства компонента для функциональности X
    */
   export interface NewFeatureComponentProps {
     /** Данные */
     data: NewFeature;
     /** Обработчик события */
     onEvent: (id: string) => void;
     // Остальные свойства
   }
   ```

3. **Обновление индексного файла**:
   ```typescript
   // src/types/index.ts
   
   // Существующие импорты
   export * from './common';
   export * from './product';
   // ...
   
   // Добавьте новый импорт
   export * from './feature';
   ```

4. **Обновление документации**:
   - Добавьте информацию о новом типе в `types/README.md`

#### Обработка ошибок типизации

1. **Проверка типов перед коммитом**:
   ```bash
   npm run type-check
   ```

2. **Решение проблем с типами**:
   - Если свойство компонента требует тип, который отсутствует в типах, добавьте новый тип
   - При несоответствии типов в разных частях кода, обновите типы в централизованном хранилище

3. **Миграция локальных типов**:
   - Если обнаружили локально определенный тип, перенесите его в централизованное хранилище
   - Обновите все импорты

## Общие компоненты

В проекте реализованы универсальные компоненты для обеспечения единообразия интерфейса и улучшения пользовательского опыта.

### LazyImage

Компонент `LazyImage` предназначен для оптимизации загрузки изображений и улучшения пользовательского опыта:

```tsx
// src/components/common/LazyImage.tsx
import Skeleton from './Skeleton';

interface LazyImageProps {
  src: string;
  alt: string;
  fallbackSrc?: string;
  className?: string;
  containerClassName?: string;
  objectFit?: 'cover' | 'contain' | 'fill' | 'scale-down';
  width?: string;
  height?: string;
  aspectRatio?: number;
}

const LazyImage = ({ src, alt, ... }: LazyImageProps) => {
  // Реализация
}
```

#### Ключевые особенности:

1. **Отложенная загрузка изображений** - компонент отображает скелетон во время загрузки изображения
2. **Обработка ошибок** - автоматическое использование изображения-заглушки в случае ошибки загрузки
3. **Сохранение соотношения сторон** - через пропс `aspectRatio` можно задать соотношение сторон
4. **Контроль за стилями** - гибкая настройка внешнего вида через пропсы
5. **Сброс состояния при изменении источника** - автоматический сброс статуса загрузки при изменении `src`

#### Пример использования:

```tsx
<LazyImage 
  src="/images/product.jpg" 
  alt="Букет цветов" 
  aspectRatio={1.5} // соотношение ширины к высоте (3:2)
  objectFit="cover"
  className="product-image"
/>
```

### Skeleton

Компонент `Skeleton` используется для отображения состояния загрузки данных, предотвращая "скачки" в интерфейсе:

```tsx
// src/components/common/Skeleton.tsx
interface SkeletonProps {
  width?: string | number;
  height?: string | number;
  borderRadius?: string | number;
  className?: string;
}

const Skeleton = ({ width = '100%', height = '1rem', ... }: SkeletonProps) => {
  // Реализация
}
```

#### Ключевые особенности:

1. **Универсальность** - может использоваться для любых загружаемых элементов (текст, изображения, карточки)
2. **Кастомизация размеров** - настройка через пропсы `width` и `height`
3. **Гибкая стилизация** - настройка скругления углов и дополнительные классы
4. **Плавная анимация** - эффект пульсации для индикации процесса загрузки
5. **Доступность** - скрыт от скринридеров с помощью `aria-hidden="true"`

#### Пример использования:

```tsx
<div className="product-card">
  {isLoading ? (
    <>
      <Skeleton height="200px" className="product-card__image-skeleton" />
      <Skeleton width="80%" height="24px" className="product-card__title-skeleton" />
      <Skeleton width="50%" height="18px" className="product-card__price-skeleton" />
    </>
  ) : (
    // Контент карточки товара
  )}
</div>
```

### Modal

Универсальный компонент `Modal` для отображения модальных окон с анимацией и поддержкой темной темы:

```tsx
// src/components/common/Modal.tsx
import { createPortal } from 'react-dom';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
  title?: string;
  isLoading?: boolean;
  skeletonConfig?: {
    count?: number;
    height?: string | number;
    spacing?: string | number;
  };
}

const Modal = ({ isOpen, onClose, children, ... }: ModalProps) => {
  // Реализация
}
```

#### Ключевые особенности:

1. **Портал в React** - модальное окно рендерится непосредственно в `document.body` через `createPortal`
2. **Анимации открытия/закрытия** - плавные CSS-анимации с тайм-аутами
3. **Автоматическое определение темы** - поддержка светлой и темной темы
4. **Индикация загрузки** - встроенные скелетоны для отображения состояния загрузки
5. **Доступность** - закрытие по клавише Escape, фокус-ловушка, правильная семантика
6. **Блокировка прокрутки страницы** - автоматическая блокировка прокрутки основного контента при открытии модального окна

#### Пример использования:

```tsx
const [isModalOpen, setIsModalOpen] = useState(false);
const [isLoading, setIsLoading] = useState(false);

// В компоненте
<button onClick={() => setIsModalOpen(true)}>Открыть модальное окно</button>

<Modal
  isOpen={isModalOpen}
  onClose={() => setIsModalOpen(false)}
  title="Оформление заказа"
  isLoading={isLoading}
  skeletonConfig={{ count: 4, height: '3rem' }}
>
  {/* Содержимое модального окна */}
  <form className="order-form">
    {/* ... */}
  </form>
</Modal>
```

### Icon

Компонент `Icon` предоставляет унифицированный способ использования SVG-иконок в проекте:

```tsx
// src/components/common/Icon.tsx
interface IconProps {
  name: 'telegram' | 'whatsapp' | 'instagram' | 'sun' | 'moon' | 'cart' | 'profile' | 
        'location' | 'clock' | 'phone' | 'check' | 'truck' | 'store' | 'lightning' |
        'leaf' | 'diamond' | 'heart' | 'handshake' | 'search';
  size?: number;
  color?: string;
  className?: string;
}

const Icon = ({ name, size = 24, color = 'currentColor', className = '' }: IconProps) => {
  // Реализация
}
```

#### Ключевые особенности:

1. **Централизованный подход** - все иконки проекта определены в одном компоненте
2. **Строгая типизация** - использование TypeScript для предотвращения ошибок при вызове иконок
3. **Категоризация иконок** - логическая группировка (социальные сети, интерфейсные иконки, и т.д.)
4. **Кастомизация** - возможность изменять размер, цвет и добавлять классы
5. **Доступность** - правильная настройка `aria-hidden` для корректной работы скринридеров
6. **Оптимизация** - использование встроенных SVG вместо внешних файлов

#### Пример использования:

```tsx
// Использование иконки по умолчанию
<Icon name="cart" />

// Кастомизированная иконка
<Icon 
  name="heart" 
  size={32} 
  color="#D4A977" 
  className="product-card__favorite-icon" 
/>

// В кнопке переключения темы
<button className="theme-toggle" onClick={toggleTheme}>
  <Icon name={isDarkTheme ? 'sun' : 'moon'} />
</button>
```

### Анимации в проекте

В проекте используется систематизированный подход к анимациям для обеспечения плавного взаимодействия с пользователем.

#### Основные принципы:

1. **CSS-анимации** - преимущественное использование CSS для анимаций вместо JavaScript для лучшей производительности
2. **Управление через состояния** - анимации контролируются через React-состояния
3. **Декларативный подход** - использование классов для включения/отключения анимаций
4. **Тайм-ауты для последовательных анимаций** - координация анимаций с помощью setTimeout
5. **Анимации для обратной связи** - визуальный отклик на действия пользователя

#### Примеры реализации:

1. **Модальные окна**:
   ```tsx
   // Управление анимацией закрытия
   const handleClose = useCallback(() => {
     setIsClosing(true);
     setIsContentVisible(false);
     setTimeout(() => {
       setIsClosing(false);
       onClose();
     }, 300); // Время анимации
   }, [onClose]);
   ```

2. **Кнопки**:
   ```css
   .button {
     transition: transform 0.2s, box-shadow 0.2s;
   }
   
   .button:hover {
     transform: translateY(-2px);
     box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
   }
   
   .button:active {
     transform: translateY(0);
   }
   ```

3. **Карточки товаров**:
   ```css
   .product-card {
     transition: transform 0.3s, box-shadow 0.3s;
   }
   
   .product-card:hover {
     transform: translateY(-5px);
     box-shadow: 0 10px 25px rgba(212, 169, 119, 0.15);
   }
   ```

#### Ключевые CSS-переменные для анимаций:

Для поддержания согласованности все длительности анимаций определены через переменные:

```css
:root {
  --animation-duration-fast: 150ms;
  --animation-duration-normal: 300ms;
  --animation-duration-slow: 500ms;
  --animation-easing-default: cubic-bezier(0.4, 0, 0.2, 1);
  --animation-easing-in: cubic-bezier(0.4, 0, 1, 1);
  --animation-easing-out: cubic-bezier(0, 0, 0.2, 1);
}
```

## Описание компонентов

В этом разделе описаны основные компоненты проекта, их назначение и структура. Компоненты логически сгруппированы по директориям в соответствии с их функциональностью.

### Корневой компонент

- **App.tsx** - Корневой компонент приложения, определяющий маршрутизацию и основную структуру. Использует `React.lazy()` для оптимизации загрузки страниц.

### Общие компоненты (`src/components/common/`)

Универсальные компоненты, используемые во всем приложении:

1. **BazaarLogo** - Компонент для отображения логотипа BAZAAR.

2. **Icon** - Компонент для отображения SVG-иконок:
   - Поддерживает множество иконок: социальные сети, интерфейсные иконки, иконки доставки и др.
   - Принимает параметры: имя иконки, размер, цвет, дополнительные классы.
   - Обеспечивает унифицированный подход к использованию иконок.

3. **LazyImage** - Компонент для оптимизированной загрузки изображений:
   - Отображает скелетон во время загрузки.
   - Автоматически использует fallback-изображение при ошибке загрузки.
   - Поддерживает настройку соотношения сторон, стилей и режима отображения.

4. **Modal** - Компонент модальных окон:
   - Реализован с использованием React Portal.
   - Включает анимации открытия/закрытия.
   - Поддерживает доступность (ARIA, закрытие по Esc, ловушка фокуса).
   - Имеет встроенную поддержку состояния загрузки со скелетонами.

5. **ProductCard** - Компонент карточки товара:
   - Отображает изображение товара, название, цену.
   - Поддерживает разные варианты отображения (для каталога, для корзины).
   - Включает анимацию при добавлении в корзину.
   - Автоматически форматирует цену.

6. **SearchField** - Компонент поля поиска:
   - Поле ввода с кнопкой поиска.
   - Поддерживает кастомизацию через классы.
   - Интегрирован с компонентом Icon.

7. **Skeleton** - Компонент для отображения состояния загрузки:
   - Используется для предотвращения "скачков" интерфейса.
   - Поддерживает настройку размеров, скругления углов.
   - Включает плавную анимацию пульсации.

8. **SocialLinks** - Компонент для отображения ссылок на социальные сети.

9. **StoreAddresses** - Компонент для отображения адресов магазинов.

### Компоненты макета (`src/components/layout/`)

Компоненты, формирующие структуру страницы:

1. **Header** - Компонент шапки сайта:
   - Содержит логотип, навигацию, кнопки корзины, профиля и переключения темы.
   - Включает мобильное меню-бургер для узких экранов.
   - Поддерживает "прилипание" при прокрутке.
   - Отображает счетчик товаров в корзине.

2. **Footer** - Компонент подвала сайта:
   - Содержит логотип, ссылки на разделы сайта, контактную информацию.
   - Включает навигацию по основным разделам.
   - Отображает адреса магазинов и социальные сети.
   - Автоматически обновляет год в копирайте.

3. **Navigation** - Компонент навигации:
   - Отображает основные пункты меню.
   - Подсвечивает активный пункт.
   - Поддерживает обработчики событий.

4. **SideMenu** - Компонент бокового меню:
   - Используется для мобильной навигации.
   - Включает анимацию появления/исчезновения.
   - Содержит навигацию, контакты и адреса магазинов.

### Компоненты карты (`src/components/map/`)

Компоненты для работы с картами и отображения магазинов:

1. **StoresMap** - Компонент карты магазинов:
   - Отображает интерактивную карту с маркерами магазинов.
   - Интегрирован с библиотекой OpenLayers.
   - Поддерживает выбор магазина и отображение ошибок загрузки.
   - Оптимизирован для мобильных устройств.

2. **StoresList** - Компонент списка магазинов:
   - Отображает список магазинов с возможностью выбора.
   - Подсвечивает выбранный магазин.
   - Синхронизируется с картой.

3. **StoreDetails** - Компонент деталей магазина:
   - Отображает подробную информацию о выбранном магазине.
   - Включает фото, адрес, телефон и статус работы.
   - Использует компонент LazyImage для загрузки фотографий.

4. **StoresModal** - Модальное окно с картой магазинов:
   - Комбинирует карту, список и детали магазинов.
   - Использует reducer для управления состоянием.
   - Реализует плавные переходы между состояниями.

### Компоненты каталога (`src/components/catalog/`)

Компоненты для отображения каталога товаров:

1. **Catalog** - Основной компонент каталога:
   - Отображает сетку товаров с фильтрацией и сортировкой.
   - Поддерживает пагинацию.

2. **FilterPanel** - Панель фильтров:
   - Содержит фильтры по цене, цвету, категории.
   - Поддерживает сохранение состояния фильтров.

3. **ColorFilter** - Фильтр по цвету:
   - Отображает цветовые варианты товаров.
   - Поддерживает множественный выбор.

4. **PriceFilter** - Фильтр по цене:
   - Позволяет выбрать диапазон цен.
   - Включает ползунки для удобства выбора.

5. **AddToCartAnimation** - Анимация добавления в корзину:
   - Создает визуальный эффект перемещения товара в корзину.
   - Улучшает пользовательский опыт.

### Компоненты продуктов (`src/components/products/`)

Компоненты для отображения информации о товарах:

1. **ProductDetail** - Компонент детальной страницы товара:
   - Отображает полную информацию о товаре.
   - Включает галерею изображений, описание, цену.
   - Содержит кнопки для добавления в корзину.

2. **ProductGallery** - Галерея изображений товара:
   - Позволяет просматривать несколько изображений товара.
   - Поддерживает увеличение изображений.

3. **RelatedProducts** - Связанные товары:
   - Отображает товары, похожие на текущий.
   - Включает горизонтальный скроллинг.

### Компоненты корзины (`src/components/cart/`)

Компоненты для работы с корзиной:

1. **CartItem** - Компонент элемента корзины:
   - Отображает товар в корзине.
   - Позволяет изменять количество или удалять товар.

2. **CartSummary** - Сводка по корзине:
   - Отображает общую стоимость, скидки, итог.
   - Включает кнопку оформления заказа.

3. **CheckoutForm** - Форма оформления заказа:
   - Содержит поля для ввода данных доставки.
   - Поддерживает выбор способа оплаты и доставки.

### Компоненты коллекций (`src/components/collections/`)

Компоненты для отображения коллекций товаров:

1. **Collection** - Компонент коллекции:
   - Отображает группу товаров, объединенных общей темой.
   - Поддерживает различные стили отображения.

2. **CollectionsList** - Список коллекций:
   - Отображает доступные коллекции.
   - Включает красивую анимацию при наведении.

3. **SeasonalCollection** - Сезонные коллекции:
   - Специальные коллекции в зависимости от текущего сезона.
   - Автоматически обновляется.

### Компоненты квиза (`src/components/quiz/`)

Компоненты для интерактивного квиза по подбору букета:

1. **Quiz** - Основной компонент квиза:
   - Управляет процессом прохождения квиза.
   - Собирает и обрабатывает ответы пользователя.

2. **QuizStep** - Компонент шага квиза:
   - Отображает вопрос и варианты ответов.
   - Поддерживает разные типы вопросов (выбор, ввод текста).

3. **QuizResult** - Результат квиза:
   - Отображает подобранный букет на основе ответов.
   - Позволяет добавить результат в корзину.

### Компоненты страниц (`src/components/pages/`)

Компоненты для отдельных страниц сайта:

1. **HomePage** - Главная страница:
   - Включает баннер, популярные коллекции, преимущества.
   - Оптимизирована для конверсии.

2. **CatalogPage** - Страница каталога:
   - Объединяет компоненты каталога, фильтрации, сортировки.
   - Поддерживает параметры URL для фильтров.

3. **ProductPage** - Страница товара:
   - Отображает детальную информацию о товаре.
   - Включает галерею, описание, связанные товары.

4. **CartPage** - Страница корзины:
   - Отображает содержимое корзины и форму оформления заказа.
   - Рассчитывает итоговую стоимость.

5. **DeliveryPage** - Страница доставки:
   - Описывает способы и условия доставки.
   - Включает интерактивную карту зон доставки.

6. **ContactsPage** - Страница контактов:
   - Отображает контактную информацию и карту магазинов.
   - Включает форму обратной связи.

7. **AboutPage** - Страница о компании:
   - Рассказывает о истории и ценностях компании.
   - Включает фотографии команды и магазинов.

8. **BlogPage** - Страница блога:
   - Отображает список статей блога.
   - Поддерживает пагинацию и фильтрацию.

9. **BlogPostPage** - Страница статьи блога:
   - Отображает полный текст статьи.
   - Включает связанные статьи и комментарии.

10. **ProfilePage** - Страница профиля:
    - Отображает информацию о пользователе, историю заказов.
    - Позволяет редактировать личные данные.

11. **VacanciesPage** - Страница вакансий:
    - Отображает список доступных вакансий.
    - Позволяет отправить резюме.

12. **PrivacyPage** - Страница политики конфиденциальности.

## Оптимизация производительности

### Мемоизация

Для оптимизации повторных рендеров используйте:
- `React.memo()` для компонентов
- `useMemo()` для вычислительно затратных операций
- `useCallback()` для функций, передаваемых дочерним компонентам

### Code Splitting

В проекте уже настроено разделение кода с помощью динамических импортов и `React.lazy()`.

### Ленивая загрузка изображений

Помимо атрибута `loading="lazy"` для тегов `<img>`, в проекте используется специализированный компонент `LazyImage`, который обеспечивает:

- Оптимизированную загрузку изображений с плейсхолдерами
- Контроль за соотношением сторон для предотвращения сдвигов макета
- Единообразное отображение состояния загрузки с помощью компонента `Skeleton`
- Обработку ошибок загрузки с автоматической подстановкой изображения-заглушки

Это позволяет значительно улучшить производительность и пользовательский опыт на страницах с большим количеством изображений.

## Масштабирование проекта

### Добавление новых компонентов

1. Создайте новый компонент в соответствующей директории (`src/components/`)
2. Следуйте принятой структуре:
   ```tsx
   import { ReactElement } from 'react';
   
   interface NewComponentProps {
     // пропсы компонента
   }
   
   const NewComponent = ({ prop1, prop2 }: NewComponentProps): ReactElement => {
     // логика компонента
     
     return (
       <div className="new-component">
         {/* JSX разметка */}
       </div>
     );
   };
   
   export default NewComponent;
   ```

### Добавление новых страниц

1. Создайте компонент страницы в директории `src/components/pages/`
2. Зарегистрируйте маршрут в `App.tsx`:
   ```tsx
   const NewPage = lazy(() => import('./pages/NewPage'));
   
   // Внутри Routes
   <Route path="/new-page" element={<NewPage />} />
   ```

### Добавление новых функций в состояние

1. Создайте новый срез в директории `src/store/`:
   ```ts
   import { createSlice, PayloadAction } from '@reduxjs/toolkit';
   
   interface NewFeatureState {
     // состояние
   }
   
   const initialState: NewFeatureState = {
     // начальное состояние
   };
   
   const newFeatureSlice = createSlice({
     name: 'newFeature',
     initialState,
     reducers: {
       // редьюсеры
     },
   });
   
   export const { actions } = newFeatureSlice;
   export default newFeatureSlice.reducer;
   ```
   
2. Добавьте срез в хранилище в `src/store/store.ts`:
   ```ts
   import newFeatureReducer from './newFeatureSlice';
   
   const store = configureStore({
     reducer: {
       // существующие редьюсеры
       newFeature: newFeatureReducer,
     },
   });
   ```

### Расширение API интеграции

Для будущей интеграции с бэкендом рекомендуется использовать RTK Query:

1. Создайте новый файл `src/store/api.ts` с определением API:
   ```ts
   import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
   
   export const api = createApi({
     reducerPath: 'api',
     baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
     endpoints: (builder) => ({
       // определение эндпоинтов
     }),
   });
   ```

2. Добавьте API в хранилище:
   ```ts
   import { api } from './api';
   
   const store = configureStore({
     reducer: {
       // существующие редьюсеры
       [api.reducerPath]: api.reducer,
     },
     middleware: (getDefaultMiddleware) =>
       getDefaultMiddleware().concat(api.middleware),
   });
   ```

## Деплой

### Подготовка к продакшену

1. Соберите проект:
   ```bash
   npm run build
   ```

2. Проверьте содержимое директории `dist/`

### Хостинг

Проект подготовлен для деплоя на статических хостингах:
- Netlify
- Vercel
- GitHub Pages
- Firebase Hosting

## Дизайн-система

Подробное руководство по стилю и дизайн-система представлены в файле `README-style-guide.md`. Основные элементы:

### Цветовая схема
- **Основной цвет**: Теплое золото (#D4A977)
- **Вторичный цвет**: Кремовый пастельный (#E8D6C6)
- **Акцентный цвет**: Приглушенное золото (#B89F7A)
- **Фон**: Очень светлый кремовый (#FFFBF6) для светлой темы и глубокий черный (#121212) для темной

### Типографика
- **Основной шрифт**: Montserrat (sans-serif)
- **Заголовки**: Cormorant Garamond (serif)
- **Акцентный шрифт**: Playfair Display (serif)

## Советы для разработчика

1. **Начинайте с малого**. Изучите компоненты в директории `common/` и `layout/` для понимания стиля и структуры проекта.

2. **Используйте Chrome DevTools**. Инструменты разработчика в браузере помогут вам отлаживать и оптимизировать приложение.

3. **Следуйте руководству по стилю**. Все новые компоненты должны соответствовать дизайн-системе проекта.

4. **Регулярно проверяйте код с ESLint**:
   ```bash
   npm run lint
   ```

5. **Используйте ветки для новых функций**. Разрабатывайте новые функции в отдельных ветках и объединяйте их через pull-запросы.

6. **Документируйте код**. Добавляйте комментарии к сложным частям кода и JSDoc к функциям.

7. **Оптимизируйте изображения**. Используйте современные форматы изображений (WebP) и оптимизируйте размеры для быстрой загрузки.

## Заключение

Данная документация предоставляет основные сведения о проекте BAZAAR, его структуре, технологиях и подходах к разработке. Для более глубокого понимания кодовой базы рекомендуется изучить исходный код проекта, особенно ключевые компоненты и хранилище Redux.

При возникновении вопросов обращайтесь к руководителю проекта или другим разработчикам команды. 