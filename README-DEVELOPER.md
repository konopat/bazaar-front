# BAZAAR - Документация для разработчиков

## Обзор проекта

BAZAAR - это онлайн-магазин по продаже цветочных букетов, разработанный с использованием современного стека технологий React. Проект реализует красивый и элегантный дизайн в стиле модного дома с золотыми акцентами и цветочными мотивами.

## Технологический стек

### Основные технологии
- **React 18** - библиотека для создания пользовательских интерфейсов
- **TypeScript** - типизированный JavaScript
- **React Router v6** - роутинг приложения
- **Redux Toolkit** - управление состоянием приложения
- **Webpack 5** - сборка проекта
- **OpenLayers** - карты для страницы контактов и доставки

### Инструменты разработки
- **ESLint** - статический анализ кода
- **Babel** - транспиляция кода
- **Webpack Dev Server** - локальный сервер разработки

## Структура проекта

```
bazaar-front/
├── dist/               # Собранный проект (создается при сборке)
├── node_modules/       # Зависимости проекта
├── public/             # Статические файлы
├── src/                # Исходный код
│   ├── components/     # React компоненты
│   │   ├── App.tsx     # Корневой компонент приложения
│   │   ├── common/     # Общие компоненты (кнопки, формы и т.д.)
│   │   ├── layout/     # Компоненты макета (шапка, подвал)
│   │   ├── pages/      # Компоненты страниц
│   │   ├── catalog/    # Компоненты каталога товаров
│   │   ├── cart/       # Компоненты корзины
│   │   ├── products/   # Компоненты товаров
│   │   ├── collections/# Компоненты для коллекций
│   │   ├── map/        # Компоненты для работы с картой
│   │   └── quiz/       # Компоненты для квиза выбора букета
│   ├── constants/      # Константы проекта
│   ├── fonts/          # Шрифты
│   ├── hooks/          # Пользовательские хуки
│   ├── images/         # Изображения
│   ├── mocks/          # Моковые данные для разработки
│   ├── store/          # Redux хранилище
│   │   ├── store.ts    # Конфигурация хранилища
│   │   └── cartSlice.ts# Срез для работы с корзиной
│   ├── styles/         # Стили CSS
│   ├── types/          # TypeScript типы
│   ├── index.css       # Базовые стили
│   └── index.tsx       # Точка входа приложения
├── .eslintrc.js        # Конфигурация ESLint
├── .gitignore          # Файлы, игнорируемые Git
├── package.json        # Зависимости и скрипты
├── package-lock.json   # Точные версии зависимостей
├── README.md           # Основная документация проекта
├── README-style-guide.md # Руководство по стилю
├── tsconfig.json       # Конфигурация TypeScript
└── webpack.config.js   # Конфигурация сборки
```

## Установка и запуск

### Требования
- Node.js >= 16.x
- npm >= 8.x

### Установка
```bash
# Клонирование репозитория
git clone <url-репозитория>
cd bazaar-front

# Установка зависимостей
npm install
```

### Запуск для разработки
```bash
npm start
```
Приложение будет доступно по адресу [http://localhost:3000](http://localhost:3000)

### Сборка для продакшена
```bash
npm run build
```
Собранное приложение будет находиться в директории `dist/`

### Анализ бандла
```bash
npm run analyze
```
Откроет интерактивный анализатор размера бандла

## Разработка

### Архитектура приложения

Проект построен по принципу компонентного подхода с использованием функциональных компонентов React. Для управления состоянием используется Redux Toolkit.

#### Маршрутизация

Маршрутизация реализована с помощью React Router v6. Основные маршруты определены в компоненте `App.tsx`. Для оптимизации используется ленивая загрузка страниц с помощью `React.lazy()`.

#### Состояние приложения

Глобальное состояние хранится в Redux хранилище. Для каждого логического раздела создаются отдельные срезы (slices).

Пример структуры хранилища:
- `cart` - состояние корзины (товары, общая сумма)

#### Стилизация

Для стилизации используется CSS с методологией БЭМ. Цветовая схема и типографика определены в руководстве по стилю (`README-style-guide.md`).

#### Требования к верстке и стилям

1. **Логические свойства CSS**
   - Использовать логические свойства вместо физических (direction-based) свойств:
     ```css
     /* Вместо этого */
     .element {
       margin-left: 1rem;
       padding-right: 2rem;
     }
     
     /* Использовать это */
     .element {
       margin-inline-start: 1rem;
       padding-inline-end: 2rem;
     }
     ```
   - Это обеспечивает лучшую поддержку интернационализации и разных направлений текста (RTL/LTR)

2. **Доступность (Web Accessibility)**
   - Соблюдать стандарты WCAG 2.1 (уровень AA)
   - Использовать атрибуты ARIA при необходимости (`aria-label`, `aria-expanded` и т.д.)
   - Обеспечивать достаточный контраст текста (минимум 4.5:1)
   - Поддерживать навигацию с клавиатуры (фокус, tabindex)
   - Добавлять метки к полям форм (связывать label с input)
   - Оптимизировать для скринридеров (правильная структура заголовков, альтернативный текст)
   - Тестировать с помощью инструментов аудита доступности (Lighthouse, axe)

3. **Семантическая верстка**
   - Использовать максимально семантические HTML-элементы:
     - `<header>`, `<footer>`, `<main>` для структуры страницы
     - `<article>`, `<section>`, `<nav>` для содержимого
     - `<button>` для кнопок (а не `<div>` с обработчиком)
     - `<ul>`, `<ol>` для списков
   - Избегать лишних оберток и вложенных `<div>`
   - В идеале стремиться к минимальному использованию `<div>`, заменяя их на семантические элементы
   - Использовать элементы по их предназначению (например, не использовать `<h1>` просто для стилизации)
   - Правильно применять заголовки (`<h1>` - `<h6>`) для создания иерархии документа

```css
/* Пример правильного использования семантической верстки */
<article class="product-card">
  <header class="product-card__header">
    <h3 class="product-card__title">Букет "Весенний"</h3>
  </header>
  <figure class="product-card__image-container">
    <img class="product-card__image" src="..." alt="Букет Весенний из тюльпанов и роз" />
  </figure>
  <footer class="product-card__footer">
    <p class="product-card__price">2 500 ₽</p>
    <button class="button product-card__button" type="button">В корзину</button>
  </footer>
</article>
```

### Руководство по стилю кода

#### Общие принципы
- Использовать функциональные компоненты
- TypeScript для всего кода
- Правила ESLint для обеспечения качества кода

#### Именование
- Компоненты: PascalCase (например, `ProductCard.tsx`)
- Хуки: camelCase с префиксом `use` (например, `useCart.ts`)
- Стили: kebab-case (например, `product-card.css`)

#### Импорты
- Использовать алиасы для импортов (`@components`, `@store`, и т.д.)
- Порядок импортов:
  1. Внешние библиотеки
  2. Типы, интерфейсы, утилиты
  3. Компоненты
  4. Стили

#### Типизация
- Использовать интерфейсы для пропсов компонентов
- Избегать `any`
- Использовать точечные импорты типов

## Общие компоненты

В проекте реализованы универсальные компоненты для обеспечения единообразия интерфейса и улучшения пользовательского опыта.

### LazyImage

Компонент `LazyImage` предназначен для оптимизации загрузки изображений и улучшения пользовательского опыта:

```tsx
// src/components/common/LazyImage.tsx
import Skeleton from './Skeleton';

interface LazyImageProps {
  src: string;
  alt: string;
  fallbackSrc?: string;
  className?: string;
  containerClassName?: string;
  objectFit?: 'cover' | 'contain' | 'fill' | 'scale-down';
  width?: string;
  height?: string;
  aspectRatio?: number;
}

const LazyImage = ({ src, alt, ... }: LazyImageProps) => {
  // Реализация
}
```

#### Ключевые особенности:

1. **Отложенная загрузка изображений** - компонент отображает скелетон во время загрузки изображения
2. **Обработка ошибок** - автоматическое использование изображения-заглушки в случае ошибки загрузки
3. **Сохранение соотношения сторон** - через пропс `aspectRatio` можно задать соотношение сторон
4. **Контроль за стилями** - гибкая настройка внешнего вида через пропсы
5. **Сброс состояния при изменении источника** - автоматический сброс статуса загрузки при изменении `src`

#### Пример использования:

```tsx
<LazyImage 
  src="/images/product.jpg" 
  alt="Букет цветов" 
  aspectRatio={1.5} // соотношение ширины к высоте (3:2)
  objectFit="cover"
  className="product-image"
/>
```

### Skeleton

Компонент `Skeleton` используется для отображения состояния загрузки данных, предотвращая "скачки" в интерфейсе:

```tsx
// src/components/common/Skeleton.tsx
interface SkeletonProps {
  width?: string | number;
  height?: string | number;
  borderRadius?: string | number;
  className?: string;
}

const Skeleton = ({ width = '100%', height = '1rem', ... }: SkeletonProps) => {
  // Реализация
}
```

#### Ключевые особенности:

1. **Универсальность** - может использоваться для любых загружаемых элементов (текст, изображения, карточки)
2. **Кастомизация размеров** - настройка через пропсы `width` и `height`
3. **Гибкая стилизация** - настройка скругления углов и дополнительные классы
4. **Плавная анимация** - эффект пульсации для индикации процесса загрузки
5. **Доступность** - скрыт от скринридеров с помощью `aria-hidden="true"`

#### Пример использования:

```tsx
<div className="product-card">
  {isLoading ? (
    <>
      <Skeleton height="200px" className="product-card__image-skeleton" />
      <Skeleton width="80%" height="24px" className="product-card__title-skeleton" />
      <Skeleton width="50%" height="18px" className="product-card__price-skeleton" />
    </>
  ) : (
    // Контент карточки товара
  )}
</div>
```

### Modal

Универсальный компонент `Modal` для отображения модальных окон с анимацией и поддержкой темной темы:

```tsx
// src/components/common/Modal.tsx
import { createPortal } from 'react-dom';

interface ModalProps {
  isOpen: boolean;
  onClose: () => void;
  children: React.ReactNode;
  title?: string;
  isLoading?: boolean;
  skeletonConfig?: {
    count?: number;
    height?: string | number;
    spacing?: string | number;
  };
}

const Modal = ({ isOpen, onClose, children, ... }: ModalProps) => {
  // Реализация
}
```

#### Ключевые особенности:

1. **Портал в React** - модальное окно рендерится непосредственно в `document.body` через `createPortal`
2. **Анимации открытия/закрытия** - плавные CSS-анимации с тайм-аутами
3. **Автоматическое определение темы** - поддержка светлой и темной темы
4. **Индикация загрузки** - встроенные скелетоны для отображения состояния загрузки
5. **Доступность** - закрытие по клавише Escape, фокус-ловушка, правильная семантика
6. **Блокировка прокрутки страницы** - автоматическая блокировка прокрутки основного контента при открытии модального окна

#### Пример использования:

```tsx
const [isModalOpen, setIsModalOpen] = useState(false);
const [isLoading, setIsLoading] = useState(false);

// В компоненте
<button onClick={() => setIsModalOpen(true)}>Открыть модальное окно</button>

<Modal
  isOpen={isModalOpen}
  onClose={() => setIsModalOpen(false)}
  title="Оформление заказа"
  isLoading={isLoading}
  skeletonConfig={{ count: 4, height: '3rem' }}
>
  {/* Содержимое модального окна */}
  <form className="order-form">
    {/* ... */}
  </form>
</Modal>
```

### Icon

Компонент `Icon` предоставляет унифицированный способ использования SVG-иконок в проекте:

```tsx
// src/components/common/Icon.tsx
interface IconProps {
  name: 'telegram' | 'whatsapp' | 'instagram' | 'sun' | 'moon' | 'cart' | 'profile' | 
        'location' | 'clock' | 'phone' | 'check' | 'truck' | 'store' | 'lightning' |
        'leaf' | 'diamond' | 'heart' | 'handshake' | 'search';
  size?: number;
  color?: string;
  className?: string;
}

const Icon = ({ name, size = 24, color = 'currentColor', className = '' }: IconProps) => {
  // Реализация
}
```

#### Ключевые особенности:

1. **Централизованный подход** - все иконки проекта определены в одном компоненте
2. **Строгая типизация** - использование TypeScript для предотвращения ошибок при вызове иконок
3. **Категоризация иконок** - логическая группировка (социальные сети, интерфейсные иконки, и т.д.)
4. **Кастомизация** - возможность изменять размер, цвет и добавлять классы
5. **Доступность** - правильная настройка `aria-hidden` для корректной работы скринридеров
6. **Оптимизация** - использование встроенных SVG вместо внешних файлов

#### Пример использования:

```tsx
// Использование иконки по умолчанию
<Icon name="cart" />

// Кастомизированная иконка
<Icon 
  name="heart" 
  size={32} 
  color="#D4A977" 
  className="product-card__favorite-icon" 
/>

// В кнопке переключения темы
<button className="theme-toggle" onClick={toggleTheme}>
  <Icon name={isDarkTheme ? 'sun' : 'moon'} />
</button>
```

### Анимации в проекте

В проекте используется систематизированный подход к анимациям для обеспечения плавного взаимодействия с пользователем.

#### Основные принципы:

1. **CSS-анимации** - преимущественное использование CSS для анимаций вместо JavaScript для лучшей производительности
2. **Управление через состояния** - анимации контролируются через React-состояния
3. **Декларативный подход** - использование классов для включения/отключения анимаций
4. **Тайм-ауты для последовательных анимаций** - координация анимаций с помощью setTimeout
5. **Анимации для обратной связи** - визуальный отклик на действия пользователя

#### Примеры реализации:

1. **Модальные окна**:
   ```tsx
   // Управление анимацией закрытия
   const handleClose = useCallback(() => {
     setIsClosing(true);
     setIsContentVisible(false);
     setTimeout(() => {
       setIsClosing(false);
       onClose();
     }, 300); // Время анимации
   }, [onClose]);
   ```

2. **Кнопки**:
   ```css
   .button {
     transition: transform 0.2s, box-shadow 0.2s;
   }
   
   .button:hover {
     transform: translateY(-2px);
     box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
   }
   
   .button:active {
     transform: translateY(0);
   }
   ```

3. **Карточки товаров**:
   ```css
   .product-card {
     transition: transform 0.3s, box-shadow 0.3s;
   }
   
   .product-card:hover {
     transform: translateY(-5px);
     box-shadow: 0 10px 25px rgba(212, 169, 119, 0.15);
   }
   ```

#### Ключевые CSS-переменные для анимаций:

Для поддержания согласованности все длительности анимаций определены через переменные:

```css
:root {
  --animation-duration-fast: 150ms;
  --animation-duration-normal: 300ms;
  --animation-duration-slow: 500ms;
  --animation-easing-default: cubic-bezier(0.4, 0, 0.2, 1);
  --animation-easing-in: cubic-bezier(0.4, 0, 1, 1);
  --animation-easing-out: cubic-bezier(0, 0, 0.2, 1);
}
```

## Оптимизация производительности

### Мемоизация

Для оптимизации повторных рендеров используйте:
- `React.memo()` для компонентов
- `useMemo()` для вычислительно затратных операций
- `useCallback()` для функций, передаваемых дочерним компонентам

### Code Splitting

В проекте уже настроено разделение кода с помощью динамических импортов и `React.lazy()`.

### Ленивая загрузка изображений

Помимо атрибута `loading="lazy"` для тегов `<img>`, в проекте используется специализированный компонент `LazyImage`, который обеспечивает:

- Оптимизированную загрузку изображений с плейсхолдерами
- Контроль за соотношением сторон для предотвращения сдвигов макета
- Единообразное отображение состояния загрузки с помощью компонента `Skeleton`
- Обработку ошибок загрузки с автоматической подстановкой изображения-заглушки

Это позволяет значительно улучшить производительность и пользовательский опыт на страницах с большим количеством изображений.

## Масштабирование проекта

### Добавление новых компонентов

1. Создайте новый компонент в соответствующей директории (`src/components/`)
2. Следуйте принятой структуре:
   ```tsx
   import { ReactElement } from 'react';
   
   interface NewComponentProps {
     // пропсы компонента
   }
   
   const NewComponent = ({ prop1, prop2 }: NewComponentProps): ReactElement => {
     // логика компонента
     
     return (
       <div className="new-component">
         {/* JSX разметка */}
       </div>
     );
   };
   
   export default NewComponent;
   ```

### Добавление новых страниц

1. Создайте компонент страницы в директории `src/components/pages/`
2. Зарегистрируйте маршрут в `App.tsx`:
   ```tsx
   const NewPage = lazy(() => import('./pages/NewPage'));
   
   // Внутри Routes
   <Route path="/new-page" element={<NewPage />} />
   ```

### Добавление новых функций в состояние

1. Создайте новый срез в директории `src/store/`:
   ```ts
   import { createSlice, PayloadAction } from '@reduxjs/toolkit';
   
   interface NewFeatureState {
     // состояние
   }
   
   const initialState: NewFeatureState = {
     // начальное состояние
   };
   
   const newFeatureSlice = createSlice({
     name: 'newFeature',
     initialState,
     reducers: {
       // редьюсеры
     },
   });
   
   export const { actions } = newFeatureSlice;
   export default newFeatureSlice.reducer;
   ```
   
2. Добавьте срез в хранилище в `src/store/store.ts`:
   ```ts
   import newFeatureReducer from './newFeatureSlice';
   
   const store = configureStore({
     reducer: {
       // существующие редьюсеры
       newFeature: newFeatureReducer,
     },
   });
   ```

### Расширение API интеграции

Для будущей интеграции с бэкендом рекомендуется использовать RTK Query:

1. Создайте новый файл `src/store/api.ts` с определением API:
   ```ts
   import { createApi, fetchBaseQuery } from '@reduxjs/toolkit/query/react';
   
   export const api = createApi({
     reducerPath: 'api',
     baseQuery: fetchBaseQuery({ baseUrl: '/api' }),
     endpoints: (builder) => ({
       // определение эндпоинтов
     }),
   });
   ```

2. Добавьте API в хранилище:
   ```ts
   import { api } from './api';
   
   const store = configureStore({
     reducer: {
       // существующие редьюсеры
       [api.reducerPath]: api.reducer,
     },
     middleware: (getDefaultMiddleware) =>
       getDefaultMiddleware().concat(api.middleware),
   });
   ```

## Деплой

### Подготовка к продакшену

1. Соберите проект:
   ```bash
   npm run build
   ```

2. Проверьте содержимое директории `dist/`

### Хостинг

Проект подготовлен для деплоя на статических хостингах:
- Netlify
- Vercel
- GitHub Pages
- Firebase Hosting

## Дизайн-система

Подробное руководство по стилю и дизайн-система представлены в файле `README-style-guide.md`. Основные элементы:

### Цветовая схема
- **Основной цвет**: Теплое золото (#D4A977)
- **Вторичный цвет**: Кремовый пастельный (#E8D6C6)
- **Акцентный цвет**: Приглушенное золото (#B89F7A)
- **Фон**: Очень светлый кремовый (#FFFBF6) для светлой темы и глубокий черный (#121212) для темной

### Типографика
- **Основной шрифт**: Montserrat (sans-serif)
- **Заголовки**: Cormorant Garamond (serif)
- **Акцентный шрифт**: Playfair Display (serif)

## Советы для разработчика

1. **Начинайте с малого**. Изучите компоненты в директории `common/` и `layout/` для понимания стиля и структуры проекта.

2. **Используйте Chrome DevTools**. Инструменты разработчика в браузере помогут вам отлаживать и оптимизировать приложение.

3. **Следуйте руководству по стилю**. Все новые компоненты должны соответствовать дизайн-системе проекта.

4. **Регулярно проверяйте код с ESLint**:
   ```bash
   npm run lint
   ```

5. **Используйте ветки для новых функций**. Разрабатывайте новые функции в отдельных ветках и объединяйте их через pull-запросы.

6. **Документируйте код**. Добавляйте комментарии к сложным частям кода и JSDoc к функциям.

7. **Оптимизируйте изображения**. Используйте современные форматы изображений (WebP) и оптимизируйте размеры для быстрой загрузки.

## Заключение

Данная документация предоставляет основные сведения о проекте BAZAAR, его структуре, технологиях и подходах к разработке. Для более глубокого понимания кодовой базы рекомендуется изучить исходный код проекта, особенно ключевые компоненты и хранилище Redux.

При возникновении вопросов обращайтесь к руководителю проекта или другим разработчикам команды. 